Table StationStep {
  Id int [PK, increment]
  Name text [not null]
  CreationTime timestamp [not null]
}

Table StationStepSequence{
  Id int [PK, increment]
  StationId int [not null, ref: < Station.Id]
  StationStepId int [not null, ref: - StationStep.Id]
  SequenceNumber int [not null]

  indexes {
      (StationId, StationStepId, SequenceNumber) [unique]
  }
}

Table StationConfiguration{
  Id int [PK, increment]
  StationStepId int [not null, ref: < StationStep.Id]
  MicrostopDurationInSeconds bigint [not null]
  IgnoreMicrostopUnderThisDurationInSeconds bigint [not null]
  MinimumRunningTimeInSeconds bigint [not null]
  ThresholdForNoShiftsConsideredBreakInSecond bigint [not null]
  LowSpeedThresholdInPcsPerHour bigint [not null]
  LanguageCode varcharacter(10) [not null] //TODO: lang code len
}

Table AvailabiltyLossState{
  Id int [PK, increment]
  Value bigint [not null]
  Name text [not null]
}

Table PerformanceLossState{
  Id int [PK, increment]
  Value bigint [not null]
  Name text [not null]
}

Table AvalibilityLossStates {
    StationConfigurationId int [not null, ref: > StationConfiguration.Id]
    AvalabilityLossStateId int [not null, ref: > AvailabiltyLossState.Id]

    indexes {
        (StationConfigurationId, AvalabilityLossStateId) [PK]
    }
}

Table PerformanceLossStates {
    StationConfigurationId int [not null, ref: > StationConfiguration.Id]
    PerformanceLossStateId int [not null, ref: > PerformanceLossState.Id]

    indexes {
        (StationConfigurationId, PerformanceLossStateId) [PK]
    }
}

Table Location{
  Id int [PK, increment]
  Name text [not null, unique]
}

// SELECT create_hypertable('Count', 'Timestamp');
// CREATE INDEX ON Count (StationStep, Timestamp DESC);
Table Count {
  Id int [PK, increment]
  StationStepId int [not null, ref: < StationStep.Id]
  Count bigint [not null]
  Timestamp timestamp [not null]
  indexes {
    (StationStepId, Timestamp) [unique]
  }
}

// SELECT create_hypertable('State', 'Timestamp');
// CREATE INDEX ON State (StationStep, Timestamp DESC);
Table State {
  Id int [PK, increment]
  StationStepId int [not null, ref: < StationStep.Id]
  State bigint [not null]
  Timestamp timestamp [not null]
  indexes {
    (StationStepId, Timestamp) [unique]
  }
}


Table ProcessValueType {
  Id int [PK, increment]
  StationStepId int [not null, ref: < StationStep.Id]
  Name text [not null]
}

Table ProcessValue {
  Id int [PK, increment]
  ValueTypeId int [not null, ref: > ProcessValueType.Id]
  Value double [not null]
  Timestamp timestamp [not null]
}

Table ProcessValueError {
  Id int [PK, increment]
  ValueTypeId int [not null, ref: > ProcessValueType.Id]
  Error text [not null]
  Timestamp timestamp [not null]
}


// CHECK (BeginTimestamp < EndTimestamp)
// EXCLUDE USING gist (StationId WITH =, tstzrange(BeginTimestamp, EndTimestamp) WITH &&)
Table Shift {
  Id int [PK, increment]
  ShiftTypeId int [not null, ref: < ShiftType.Id]
  StationId int [not null, ref: < Station.Id]
  BeginTimestamp timestamp [not null]
  EndTimestamp timestamp // Allows null values, since it is not always known, when a shift ends

  indexes{
    (BeginTimestamp, StationId) [unique]
  }
}

Table ShiftType {
  Id int [PK, increment]
  Name text [not null]
}


// CHECK (BeginTimestamp < EndTimestamp)
// CHECK (TargetUnits > 0)
// EXCLUDE USING gist (StationId WITH =, tstzrange(BeginTimestamp, EndTimestamp) WITH &&) WHERE (BeginTimestamp IS NOT NULL AND EndTimestamp IS NOT NULL)
Table Order {
  Id int [PK, increment]
  StationId int [not null, ref: < Station.Id]
  Name text [not null]
  BeginTimestamp timestamp [not null]
  EndTimestamp timestamp // Allows null values, since it is not always known, when an order ends
  TargetUnits bigint [not null]

  indexes{
    (StationId, Id) [unique]
  }
}


Table StationProduct {
  Id int [PK, increment]
  StationId int [not null, ref: < Station.Id]
  ProductTypeNameId int [not null, ref: < ProductTypeName.Id]
  TimePerUnitInSeconds double [not null]
}

Table ProductTypeName{
  Id int [PK, increment]
  Name text [not null]
}

// CHECK: ProductFailureId can only be set if ProductStatus::Undefined
Table Product {
  Id int [PK, increment]
  StationStepId int [not null, ref: < StationStep.Id]
  StationProductId int [not null, ref: < StationProduct.Id]
  Value text [not null]
  ProductionBegin timestamp [not null]
  ProductionEnd timestamp
  Status ProductStatus [not null]
  ProductFailureId int [ref: < ProductFailure.Id]
}

enum ProductStatus{
  NoScrap         // Tested -> Good || No testing needed
  Scrap           // Tested -> Bad
  Undefined       // Status not known
}

Table ProductFailure{
  Id int [PK, increment]
  Value text [not null]
}

// Migrate to double hypertable
Table ProductInheritance {
  ParentId int [not null, ref: < Product.Id]
  ChildId int [not null, ref: < Product.Id]
  indexes{
    (ParentId, ChildId) [unique]
    (ParentId)
    (ChildId)
  }
}

Table Station{
  Id int [PK, increment]
  StationGroupId int [not null, ref: < StationGroup.Id]
  LocationId int [not null,ref: < Location.Id]
  Name text [not null]
  CreationTime timestamp [not null]
  indexes {
    (Name, LocationId) [unique]
  }
}


Table StationStepRelations {
    StationId int [not null, ref: > Station.Id]
    StationStepId int [not null, ref: > StationStep.Id]

    indexes {
        (StationId, StationStepId) [PK]
    }
}

Table Process{
  Id int [PK, increment]
  Name text [not null]
  CreationTime timestamp [not null]
}

Table ProcessGroupRelations {
    ProcessId int [not null, ref: > Process.Id]
    StationStepId int [not null, ref: > StationStep.Id]

    indexes {
        (ProcessId, StationStepId) [PK]
    }
}

Table StationGroup {
  Id int [PK, increment]
  Name text [not null]
  CreationTime timestamp [not null]
}


Table RecommendationInstanceTable{
  Id int [PK, increment]
  StationId int [not null, ref: < Station.Id]
  RecommendationTemplateId int [not null, ref: > RecommendationTemplate.Id]
  Timestamp timestamp [not null]
}



// TODO: Which of these keys should be not null
Table RecommendationTemplate{
  Id int [PK, increment]
  Timestamp timestamp [not null]
  Type bigint [not null]
  Enabled boolean [not null]
  Values text
  DiagnoseTextDE text
  DiagnoseTextEN text
  TextDE text
  TextEN text
}
// TODO maybe add table for translations


Table StationRecommendationRelations {
    StationId int [not null, ref: > Station.Id]
    RecommendationTemplateId int [not null, ref: > RecommendationTemplate.Id]

    indexes {
        (RecommendationTemplateId, StationId) [PK]
    }
}

Table ProductTagDouble{
  Id int [PK, increment]
  Timestamp timestamp [not null]
  ProductId int [not null, ref: > Product.Id]
  ValueName text [not null]
  Value double [not null]
}


Table ProductTagString{
  Id int [PK, increment]
  Timestamp timestamp [not null]
  ProductId int [not null, ref: > Product.Id]
  ValueName text [not null]
  Value string [not null]
}











